## 2023-04-18 / 김혜진 / PGS-마법의 엘리베이터

### n차 시도 (실패)

- 실패한 코드를 날려서.. ㅠㅠ

### n+1차 시도

```python
def solution(storey):
    answer = 0
    while storey != 0:
        storey, stone = divmod(storey, 10)
        if stone > 5 or (stone == 5 and storey % 10 >= 5):
            stone = 10 - stone
            storey += 1
        answer += stone
    return answer
```
- 더했다가 뺐다가 하는 걸 반복하는 게 아니라, (즉 storey가 양수였다가 음수였다가 반복하는 것이 아니라) 양수를 다 더해서 마지막에 빼는 방법이다.
- 10으로 나눈 나머지만큼 stone을 사용하여 이동하는데, stone이 5 이상이라면 내려가는 게 아니라 올라가는 게 유리하다.
  - ex) 67 => 70 => 100 (5), 67 => 60 => 100 (11)
- stone이 5이고, 그 다음에 사용될 stone이 5 이상일 때도 위와 마찬가지이다. 
  - ex) 455 => 460 => 500 => 0 (14), 455 => 450 => 400 => 0 (14)
  - 사실 위 예시는 결과가 똑같은데, >=에서 =를 빼면 제출했을 때 실패하는 경우가 생긴다. 반례는 아직 못 찾았다.

- 시간복잡도
```
시간 복잡도는 while 루프가 storey의 자릿수에 따라 실행되는 횟수로 결정됩니다. 
storey의 최대 자릿수가 k이면, while 루프는 약 O(k)번 실행됩니다. 
storey를 나눌 때 사용되는 divmod 함수의 시간 복잡도는 O(k)입니다. 
따라서 이 함수의 시간 복잡도는 O(k^2)입니다.
```
